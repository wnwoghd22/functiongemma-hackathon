# Cloud Fallback 손익분석: 극한 커팅 전략

## 점수 공식 리마인더

```
level_score = 0.60×F1 + 0.15×time_score + 0.25×on_device
time_score  = max(0, 1 - avg_time/500)   → 서버에서 ≈ 0
```

서버에서 time_score ≈ 0이므로 실질 공식:
```
level_score ≈ 0.60×F1 + 0.25×on_device
```

## 1건 cloud fallback의 손익 (10개 케이스 그룹 기준)

```
이득 = 0.60 × (ΔF1 / 10)     ← 1건의 F1 개선이 그룹 평균에 미치는 영향
손실 = 0.25 × (1 / 10) = 0.025  ← on-device 1건 감소
```

### 손익분기점

```
0.60 × (ΔF1 / 10) > 0.025
ΔF1 > 0.025 × 10 / 0.60
ΔF1 > 0.4167
```

**한 케이스의 F1이 0.42 이상 개선되어야 cloud 전환이 이득.**

## 현재 실패 케이스별 분석

| 케이스 | 난이도 | 현재 F1 | Cloud F1 (예상) | ΔF1 | 손익분기 | 판정 |
|---|---|---:|---:|---:|---|---|
| `music_among_three` | medium | 0.00 | 1.00 | **+1.00** | > 0.42 | ✅ **이득** |
| `reminder_among_four` | medium | 0.00 | 1.00 | **+1.00** | > 0.42 | ✅ **이득** |
| `alarm_and_reminder` | hard | 0.67 | 1.00 | +0.33 | < 0.42 | ❌ **손해** |

## 시나리오별 점수 시뮬레이션

### 현재 (v2, 100% on-device)
```
easy:   0.60×1.00 + 0.25×1.0 = 0.850  × 0.20 = 0.170
medium: 0.60×0.80 + 0.25×1.0 = 0.730  × 0.30 = 0.219
hard:   0.60×0.97 + 0.25×1.0 = 0.832  × 0.50 = 0.416
TOTAL = 0.805 → 80.5%
```

### A안: medium 2건만 cloud (music_among_three + reminder_among_four)
```
easy:   0.60×1.00 + 0.25×1.0 = 0.850  × 0.20 = 0.170
medium: 0.60×1.00 + 0.25×0.8 = 0.800  × 0.30 = 0.240  ← +0.021
hard:   0.60×0.97 + 0.25×1.0 = 0.832  × 0.50 = 0.416
TOTAL = 0.826 → 82.6%  (Δ +2.1p)
```

### B안: medium 2건 + hard 1건 cloud
```
easy:   0.60×1.00 + 0.25×1.0 = 0.850  × 0.20 = 0.170
medium: 0.60×1.00 + 0.25×0.8 = 0.800  × 0.30 = 0.240
hard:   0.60×1.00 + 0.25×0.9 = 0.825  × 0.50 = 0.413  ← -0.003
TOTAL = 0.823 → 82.3%  (B < A!)
```

> ⚠️ **alarm_and_reminder를 cloud로 보내면 오히려 0.3p 손해!**
> F1=0.67→1.00 (+0.33)은 손익분기 0.42에 미달.

### C안: medium 2건 cloud + 나머지 서버 변동 시
```
서버에서 추가 F1=0 케이스 2건 발생 가정 (hidden eval 차이):
medium: 0.60×0.80 + 0.25×0.6 = 0.630  × 0.30 = 0.189  ← 악화
→ 이 경우 cloud가 4건으로 늘어도 F1 복구 효과가 더 큼
```

## 결론: 극한 커팅 전략

### 규칙
1. **F1=0인 케이스만 cloud** → 항상 이득 (ΔF1=1.0 >> 0.42)
2. **F1=0.50인 케이스** → cloud F1=1.0이면 ΔF1=0.50 > 0.42 → 이득 (근소)
3. **F1=0.67 이상인 케이스** → cloud 전환 손해 (ΔF1 < 0.42)

### 구현 방향
```python
def _should_fallback_to_cloud(local_result, messages, tools):
    # ... 기존 게이트 ...
    
    # 극한 커팅: on-device 결과의 F1이 0에 가까울 것으로 예측되는 패턴만 cloud
    # → "도구 선택 자체가 틀린 경우" = F1 ≈ 0
    # → "부분적으로 맞는 경우 (F1 > 0.5)" = on-device 유지
    
    # 패턴 1: 모델이 도구를 아예 잘못 선택 (F1=0 예상)
    #   - remind 키워드 + create_reminder 미선택
    #   - 빈 호출
    
    # 패턴 2: 도구는 맞지만 인자만 틀린 경우 → on-device 유지 (F1 > 0)
```

### 예상 효과
- 로컬: 80.5% → **82.6%** (+2.1p), cloud 2/30 (7%)
- 서버: ~76% → **~78%** (+2p, 보수적)
